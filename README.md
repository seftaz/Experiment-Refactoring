# Experiment-Refactoring
Session 8 of Soft-Lab
<div dir="rtl">

# تغییر Facade:
برای این قسمت ما دو کلاس CodeGenerator و Parser را انتخاب میکنیم. کلاس CodeGenerator به علت محتوای زیادی که دارد از بیرون پیچیده است گزینه خوبی است. این کلاس در پارسر استفاده شده است و فقط دو فانکنالیتی آن استفاده شده است. برای این، کلاس CodeGeneratorFacade را ساختیم. توجه کنید استفاده های SemanticFunction توسط خود کد جنریتور استفاده میشوند و استفاده خارجی نیست که بخواهیم از acade استفاده کنیم. برای Parser، در main استفاده میشود و به همان شکل قبلی کلاس ParserFacade را اختصاص دادیم.

# تغییر Polyphormism:
برای این قسمت ما در CodeGenerator یک سوییچ بلند داشتیم که با تعریف یک کلاس abstract توانستیم این سوییچ را حذف کنیم و با استفاده از کلاس خود و کلاس های زیر مجموعه آن کار را جلو ببریم

# تغییر Separete Query from Modifier:
برای این کار در کلاس مموری ما برای متد های getTemp و getDataAddress ما هم تغییر داشتیم و هم ریترن ادرس که با آوردن دو متد برای تعییر به صورت جداگانه این مشکل را حل کردیم

# تغییر Self Encapsulate:
برای این کار در کلاس Lexical Analyzer ما یک تغییر دادیم که matcher که یک فیلد پرایوت است را با ستتر و گتتر بتوان تغییر داد و نه به صورت مستقیم از آن استفاده کرد.

# دو مورد تغییرات دیگر:
در وهله اول کلاس Log را سینگلتون میکنیم چون دائم از استاتیک استفاده میکرد. همچنین در کلاس پارسر یک متد خیلی بزرگ داریم که ز طریق extract method به تعدادی متد کوچکتر تجزیه کردیم.

# پاسخ به سوالات آزمایش
### سوال اول
1.	کد تمیز: کدی است که ساده، خوانا، قابل فهم و maintainable باشد و اصول بهترین شیوه‌های برنامه‌نویسی را رعایت کند.
2.	بدهی فنی: نتایج منفی حاصل انتخاب راه‌حل‌های ساده به جای راه‌حل‌های بهینه که به مرور زمان نیازمند هزینه بیشتری برای اصلاح و بهبود می‌شود.
3.	بوی بد: بخش‌های ناخوشایند در کد که می‌تواند به مشکلات بزرگ‌تر و پیچیده‌تری منجر شود، مانند تکرار کد، پیچیدگی زیاد و نام‌گذاری‌های نادرست.


 ### سوال دوم
1.	بوهای بد کلی: شامل مشکلاتی است که می‌توانند در هر بخش از کد رخ دهند، مانند تکرار کد، توابع طولانی و پیچیدگی زیاد.
2.	بوهای بد در کلاس‌ها: شامل مشکلات مربوط به طراحی و ساختار کلاس‌ها، مانند کلاس‌های بزرگ و کلاس‌های داده‌ای که فقط حاوی داده‌ها و بدون منطق هستند.
3.	بوهای بد در شیوه‌های تعاملی بین اشیاء: شامل مشکلاتی است که در نحوه تعامل و ارتباط بین اشیاء رخ می‌دهد، مانند وابستگی‌های زیاد و تعاملات غیرضروری بین کلاس‌ها.
4.	بوهای بد در استفاده از ارث‌بری: شامل مشکلات مربوط به استفاده نادرست یا بیش از حد از ارث‌بری، مانند سلسله‌مراتب ارث‌بری عمیق و فرزندان نامناسب.
5.	بوهای بد مرتبط با تغییرپذیری: شامل مشکلاتی است که تغییرات را دشوار و پرهزینه می‌کند، مانند متغیرهای سراسری و اثرات جانبی غیرمنتظره در کد.


 ### سوال سوم
-	بوی بد Lazy Class در دسته‌بندی "بوهای بد در کلاس‌ها" قرار می‌گیرد.
- برای برطرف کردن Lazy Class، از بازآرایی‌های Inline Class و Collapse Hierarchy استفاده می‌شود.
- این بو را زمانی می‌توان نادیده گرفت که کلاس به عنوان Extension Point طراحی شده یا برنامه‌ای برای توسعه آن در آینده وجود دارد.


 ### سوال چهارم
## ۱) Main.java
- **Long Method**: متد `generateInfoForXML` بسیار طولانی است و مسئولیت‌های زیادی دارد که این باعث کاهش خوانایی و نگهداری کد می‌شود.
- **Large Class**: کلاس `Main` شامل چندین متغیر استاتیک و متدهای مختلف است که مسئولیت‌های زیادی بر عهده دارد. این کلاس بیش از حد بزرگ شده است و می‌تواند به چندین کلاس کوچکتر تقسیم شود تا خوانایی و نگهداری بهبود یابد.
- **Primitive Obsession**: استفاده از انواع داده‌های ابتدایی مانند `String` برای مقادیر خاص (مانند `fileName`) به جای استفاده از اشیاء مناسب می‌تواند مشکلاتی را ایجاد کند و خوانایی کد را کاهش دهد.

## ۲) Phase1CodeGenerator.java
- **Long Method**: متد سازنده `Phase1CodeGenerator` بسیار طولانی است و مسئولیت‌های زیادی دارد که این باعث کاهش خوانایی و نگهداری کد می‌شود.
- **Feature Envy**: متدهای موجود در این کلاس به نظر می‌رسد که بیش از حد به داده‌های کلاس `CompleteDiagram` دسترسی دارند. این نشان می‌دهد که بخشی از منطق می‌تواند به کلاس `CompleteDiagram` منتقل شود.
- **Primitive Obsession**: استفاده از انواع داده‌های ابتدایی مانند `String` برای مقادیر خاص (مانند نام فایل‌ها) به جای استفاده از اشیاء مناسب می‌تواند مشکلاتی را ایجاد کند و خوانایی کد را کاهش دهد.

## ۳) Phase2CodeFileManipulator.java
- **Data Clumps**: وجود فیلدهای متعددی مانند `numberOfClassCalled`، `numberOfStructureKeywordCalled`، `numberOfClassKeywordCalled` و غیره که همیشه با هم استفاده می‌شوند، نشان دهنده وجود توده‌های داده‌ای (Data Clumps) است. این فیلدها می‌توانند به یک شیء مشترک تبدیل شوند.
- **Feature Envy**: برخی از متدها به نظر می‌رسد که بیش از حد به داده‌های کلاس `DiagramInfo` دسترسی دارند. این نشان می‌دهد که بخشی از منطق می‌تواند به کلاس `DiagramInfo` منتقل شود.
- **Temporary Field**: فیلد `writer` که فقط در برخی از شرایط خاص مقداردهی می‌شود و در سایر مواقع بلااستفاده است. این فیلد موقت می‌تواند به جای فیلد کلاس، به یک متغیر محلی در متدها تبدیل شود.

## ۴) LexicalAnalyzer.java
- **Speculative Generality**: وجود متدهای عمومی و واسط‌هایی که ممکن است برای استفاده‌های آینده تعریف شده باشند ولی در حال حاضر مورد استفاده قرار نگرفته‌اند. این باعث پیچیدگی و افزایش اندازه کد بدون دلیل موجه می‌شود. برای مثال، متدهای `deleteClassSpecifier` و `deleteTypeQualifier` که به نظر می‌رسد برای حالت‌های خاص تعریف شده‌اند ولی ممکن است به طور کامل مورد نیاز نباشند.

 ### سوال پنجم
پلاگین formatter-maven-plugin کمک می‌کند تا کدهای جاوا را با استفاده از Eclipse قالب‌بندی کنیم. این ابزار با اعمال قالب‌بندی اتوماتیک بر روی کدها، به خوانایی کد کمک می‌کند. رابطه آن با بازآرایی کد در این است که با اعمال قالب‌بندی صحیح و رعایت استانداردهای کدنویسی، از بروز برخی بوهای بد کد جلوگیری کرده و کد را تمیز و منظم نگه می‌دارد، که باعث کاهش بدهی فنی و افزایش کیفیت کلی کد می‌شود.
 
 </div>
